IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT comment as cmt
IMPORT primitive as prim
IMPORT expression as expr

<> function 

  > ( type "<-" :ast $1 )?^return_type tk:( id "\(" )  param_binding(+)^params ")" block

    :ast { t_RawFunction, params, return_type, block  }


<> param_binding 
  
  > id ":" type^ty

    :ast { t_RawParamBinding, id, ty, tok }


<> statements 
  
  > declaration 
  | block 
  | drop
  | break 
  | assignment 
  | loop 
  | match 


<> declaration 
  
  > id ":" primitive_ptr_type^ty mem_binding?^expression ";"? 

    :ast { t_RawPtrDeclaration, id, ty, expression, tok  }

  | id ":" primitive_type^ty ("=" expression)?^expression ";"?

    :ast { t_RawPrimitiveDeclaration, id, ty, expression, tok }


<> block 

  > "{" statements(+)^statements return?^ret "}"

    :ast { t_RawBlock, statements, ret  }


<> return 
  
  > "<-"  expression

    :ast { t_RawReturn, expression }
  

<> assignment 

  > (id | memory_location )(+) "=" expression(+) ";"?

    :ast { t_RawAssign, location: $1, expression, tok  }

  | (id | memory_location )(+) ( "+=" | "-=" | "/=" | "*=" | "&=" | "|=" ) expression(+) ";"?

    :ast { t_ArithmaticAssign, location: $1, expression, tok  }

  | id mem_binding^expression ";"?

    :ast { t_RawPtrAssign, id: $1, expression, tok  }


<> drop

  > "drop(" id ")" ";"?

    :ast { t_RawDrop, id  }


<> break 
  
  > "break" ";"?
    
    :ast { t_RawBreak, tok }


<> loop 
  
  > "loop" block

    :ast { t_RawLoop, block, tok  }

  | "loop" match^block

    :ast { t_RawLoop, block, tok  }


<> match 

  > "match" ( boolean | arithmetic )^expression  match_statement(+)^statements

    :ast { t_RawMatch, expression, statements, tok  }
  

<> match_statement 

  > match_case 

  | match_default


<> match_case 
  
  > ( primitive_bool | primitive_number ) block

    :ast { t_RawMatchCase, val:$1, block, tok  }

<> match_default 
  
  > ( "default" | "def" ) block^block

    :ast { t_DefaultMatchCase, block, tok  }


<> mem_binding 

  > "<-{" ( primitive_unsigned_integer | id )^byte_count "}"

    :ast { t_MemBinding, byte_count, heap: true }

  | "<-<" ( primitive_unsigned_integer | id )^byte_count ">"

    :ast { t_MemBinding, byte_count, heap: bool(false) }


<> mem_expr 

  > mem_expr^left "+"{1} mem_expr{1}^right

    :ast { t_RawMemAdd, left, right, tok }

  | mem_expr^left "*"{2} mem_expr{2}^right

    :ast { t_RawMemMul, left, right, tok }

  | id

  | primitive_integer



<> expression 

  > bitwise


<> boolean 

  > boolean^left "||"{1}  boolean{1}^right
    
    :ast { t_OR, left, right, tok } 

  | boolean^left "|||"{2}  boolean{2}^right
    
    :ast { t_XOR, left, right, tok } 

  | boolean^left "&&"{3}  boolean{3}^right
    
    :ast { t_AND, left, right, tok }

  | logical

  | "(" boolean ")"
    
    :ast $2


<> logical 

  > bitwise^left "=="{3}  bitwise{3}^right
    
    :ast { t_EQ, left, right, tok } 

  | bitwise^left "!="{3}  bitwise{3}^right
    
    :ast { t_NE, left, right, tok } 

  | bitwise^left ">="{3}  bitwise{3}^right
    
    :ast { t_GE, left, right, tok } 

  | bitwise^left "<="{3}  bitwise{3}^right
    
    :ast { t_LE, left, right, tok } 

  | bitwise^left  ">"{3}  bitwise{3}^right
    
    :ast { t_GR, left, right, tok } 

  | bitwise^left  "<"{3}  bitwise{3}^right
    
    :ast { t_LS, left, right, tok } 

  | "!"{4} logical^expr{3}
    
    :ast { t_NOT, expr } 


<> bitwise 

  > bitwise^left  ">>"{3}  bitwise{3}^right
    
    :ast { t_BIT_SR, left, right } 

  | bitwise^left  "<<"{3}  bitwise{3}^right
    
    :ast { t_BIT_SL, left, right } 

  | bitwise^left "&"{2}  bitwise{2}^right
    
    :ast { t_BIT_AND, left, right } 

  | bitwise^left "|"{2}  bitwise{2}^right
    
    :ast { t_BIT_OR, left, right } 

  | bitwise^left "~|"{2}  bitwise{2}^right
    
    :ast { t_BIT_XOR, left, right } 

  | arithmetic


<> arithmetic 
  
  > arithmetic^left   "+"{1}  arithmetic{1}^right
    
    :ast { t_Add, right, left, tok }

  | arithmetic^left   "-"{1}  arithmetic{1}^right
    
    :ast { t_Sub, right, left, tok }

  | arithmetic^left   "*"{2}  arithmetic{2}^right
    
    :ast { t_Mul, right, left, tok }

  | arithmetic^left   "/"{2}  arithmetic{2}^right
    
    :ast { t_Div, right, left, tok }

  | arithmetic^left   "%"{2}  arithmetic{2}^right
    
    :ast { t_Mod, right, left, tok }

  | arithmetic^left  "**"{3}  arithmetic{3}^right
    
    :ast { t_Pow, right, left, tok }

  | arithmetic^left  "//"{3}  arithmetic{3}^right
    
    :ast { t_Root, right, left, tok }

  | arithmetic^left "log"{3}  arithmetic{3}^right
    
    :ast { t_Log, right, left, tok }

  | Term

  | "(" bitwise ")" 
    
    :ast $2


<> Term 

  > call | member | primitive_value | memory_location | self | primitive_cast
  

<> call > id "(" expression(+",") ")"

  :ast { t_RawCall, id  }


<> member > id^root ("." id )(*)^branches

  :ast { t_RawMember, root, branches }


<> self 

  > tk:( "self." ) id

    :ast { t_RawSelfMember, id }

<> id 
  
  > prim::id^id

    :ast { t_Id, id, tok }

<> type 
  
  > primitive_type

  | primitive_ptr_type

  | table_type


<> primitive_bool 

  > prim::true

    :ast { t_RawTrue }

  | prim::false

    :ast { t_RawFalse }

<> primitive_value

  > primitive_number

  | prim::string^val

    :ast { t_RawStr, val:str($val)  }


<> primitive_number 

  > prim::sci_num

    :ast { t_RawNum, val:f64($1), tok }


<> primitive_unsigned_integer 

  > prim::uint

    :ast { t_RawUint, val:i64($1) }


<> primitive_integer 

  > prim::int

    :ast { t_RawInt, val:i64($1) }


<> table_type

  > "table" :ast { t_Type_Table }
  | "row"   :ast { t_Type_Row }



<> primitive_ptr_type

  > "*8"    :ast { t_Type_8BitPointer }
  | "*16"   :ast { t_Type_16BitPointer }
  | "*32"   :ast { t_Type_32BitPointer }
  | "*64"   :ast { t_Type_64BitPointer }
  | "*128"  :ast { t_Type_128BitPointer }
  | "*" primitive_type :ast { t_Type_Pointer, base_type:$2 }


<> primitive_type

  > "u8"    :ast { t_Type_u8 }
  | "i8"    :ast { t_Type_i8 }
  | "u16"   :ast { t_Type_u16 }
  | "i16"   :ast { t_Type_i16 }
  | "u32"   :ast { t_Type_u32 }
  | "i32"   :ast { t_Type_i32 }
  | "u64"   :ast { t_Type_u64 }
  | "i64"   :ast { t_Type_i64 }
  | "f32"   :ast { t_Type_f32 }
  | "f64"   :ast { t_Type_f64 }
  | "f128"  :ast { t_Type_f128 }
  | "f32v2" :ast { t_Type_f32v2 }
  | "f32v3" :ast { t_Type_f32v3 }
  | "f32v4" :ast { t_Type_f32v4 }
  | "f32v8" :ast { t_Type_f32v8 }
  | "f64v2" :ast { t_Type_f64v2 }
  | "f64v4" :ast { t_Type_f64v4 }


<> memory_location 

  > "[" pointer_offset "]"

    :ast $2


<> pointer_offset 

  > (pointer_cast | id)^base_ptr ( "+" mem_expr )?^expression

    :ast { t_RawMemLocation, base_ptr, expression, tok }




<> primitive_cast 

  > primitive_type^ty "(" expression ")"

    :ast { t_RawPrimitiveCast, ty, expression, tok }


<> pointer_cast 

  > primitive_ptr_type^ty "(" id ")"

    :ast { t_RawPointerCast, ty, id, tok }