IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT comment as cmt
IMPORT primitive as prim
IMPORT expression as expr

<> optimizers 

  > op_optimizer(+)^optimizations

    :ast { t_Optimizations, optimizations }

  

<> op_optimizer 

  > "when" op_name operand_declaration(+)^operands action_body^body

    :ast  { t_Optimizer, op_name, operands, body }

<> op_name 
  
  > prim::id^id

<> operand_declaration 

  > "$" prim::id^id "(" operand_match_constraint(*)^constraints ")"

    :ast { t_Operand, id, constraints }


<> operand_match_constraint 

  >  var_constraint
  |  const_constraint
  |  block_declaration_constraint
  |  iter_annotation_constraint
  |  positional_constraint


<> positional_constraint 

  > prim::uint^pos

    :ast { t_PositionalConstraint, pos:u32($pos)  }

<> var_constraint 

  > "var"

    :ast { t_VarConstraint }

<> const_constraint 
  
  > "const" 

    :ast { t_ConstConstraint }

<> block_declaration_constraint 

  > "block_iter" 

    :ast { t_BlockIterConstraint }

<> iter_annotation_constraint 

  > "loop_intrinsic" 

    :ast { t_IterAnnotationConstraint }



<> action_body 

  > "{" statements(+) "}"

    :ast  { t_OptBody, statements:$2 }


<> statements 
  >  assignment_statement 
  | continue 
  | if_statement 
  | print_all


<> print_all 
  
  > "print" 

    :ast { t_PrintAll }
 
<> continue >  "continue" :ast { t_Continue }


<> assignment_statement

  > member "="  expr 

    :ast { t_Assignment, target:$1, expr:$3 }


<> root_id >  "annotation" :ast str($1) | prim::id


<> if_statement > "if" member^expression action_body^body

  :ast { t_IfStatement, expression, body  }


<> expr 

  > expr^left "+"{2} expr{2}^right

    :ast { t_Add, left, right  }

  | expr^left "-"{2} expr{2}^right

    :ast { t_Sub, left, right  }

  | expr^left "/"{3} expr{3}^right

    :ast { t_Div, left, right  }

  | expr^left "*"{3} expr{3}^right

    :ast { t_Mul, left, right  }

  | "-"{8} expr{7}

    :ast { t_Neg, expr  }

  | term


<> term

  > numeric

  | member


<> numeric 

  > prim::sci_num

    :ast { t_Number, val:f64($1) }

  | "true"

    :ast { t_True }

  | "false"

    :ast { t_False }



<> member > 

  root_id ("." prim::id)(*)

    :ast { t_Member, root: $1, descendents:$2 }

  | "$" ("." prim::id)(*)

    :ast { t_Curr, descendents:$2 }