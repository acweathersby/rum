IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT type as ty
IMPORT ../common/primitive as prim
IMPORT ../common/comment as cmt

<> expression > expression_types

    :ast { t_Expression, expr: $1, tok }

<> expression_types

  > bitwise

  | aggregate_instantiation

<> boolean 

  > boolean^left "||"{1}  boolean{0}^right

    :ast { t_OR, left, right, tok } 

  | boolean^left "|||"{3}  boolean{2}^right

    :ast { t_XOR, left, right, tok } 

  | boolean^left "&&"{5}  boolean{4}^right

    :ast { t_AND, left, right, tok }

  | logical

  | "(" boolean ")"

    :ast $2

<> logical 

  > bitwise^left "=="{3}  bitwise{3}^right

    :ast { t_EQ, left, right, tok } 

  | bitwise^left "!="{3}  bitwise{3}^right

    :ast { t_NE, left, right, tok } 

  | bitwise^left ">="{3}  bitwise{3}^right

    :ast { t_GE, left, right, tok } 

  | bitwise^left "<="{3}  bitwise{3}^right

    :ast { t_LE, left, right, tok } 

  | bitwise^left  ">"{3}  bitwise{3}^right

    :ast { t_GR, left, right, tok } 

  | bitwise^left  "<"{3}  bitwise{3}^right

    :ast { t_LS, left, right, tok } 

  | "!"{4} logical^expr{3}

    :ast { t_NOT, expr }

<> bitwise 

  > bitwise^left  ">>"{5}  bitwise{4}^right

    :ast { t_BIT_SR, left, right, tok } 

  | bitwise^left  "<<"{5}  bitwise{4}^right

    :ast { t_BIT_SL, left, right, tok } 

  | bitwise^left "&"{3}  bitwise{2}^right

    :ast { t_BIT_AND, left, right, tok } 

  | bitwise^left "|"{3}  bitwise{2}^right

    :ast { t_BIT_OR, left, right, tok } 

  | bitwise^left "~|"{3}  bitwise{2}^right

    :ast { t_BIT_XOR, left, right, tok } 

  | arithmetic

<> arithmetic 

  > arithmetic^left   "+"{2}  arithmetic{1}^right

    :ast { t_Add, right, left, tok }

  | arithmetic^left   "-"{2}  arithmetic{1}^right

    :ast { t_Sub, right, left, tok }

  | arithmetic^left   "*"{4}  arithmetic{3}^right

    :ast { t_Mul, right, left, tok }

  | arithmetic^left   "/"{4}  arithmetic{3}^right

    :ast { t_Div, right, left, tok }

  | arithmetic^left   "%"{4}  arithmetic{3}^right

    :ast { t_Mod, right, left, tok }

  | arithmetic^left  "**"{6}  arithmetic{5}^right

    :ast { t_Pow, right, left, tok }

  | arithmetic^left  "//"{6}  arithmetic{5}^right

    :ast { t_Root, right, left, tok }

  | arithmetic^left "log"{6}  arithmetic{5}^right

    :ast { t_Log, right, left, tok }

  | "-"{7} arithmetic^expr{6}

    :ast { t_Negate, expr, tok }

  | term

<> term 

  > r_val

  | call

  | "(" expression_types ")"

    :ast $2

<> r_val 

  > primitive_value

  | member

<> l_val 

  > member

<> call 

  > member^member "("{1} expression(*",")^args ")"

    :ast { t_RawCall, member, args, tok }

<> member 

  > member_root{1}^root ( indexed_member | named_member )(*)^sub_members{2}

    :ast { t_MemberCompositeAccess, root, sub_members, tok }

<> member_load > "[" member "]"


<> indexed_member 

  >  "[" bitwise^expression "]"

    :ast  { t_IndexedMember, expression, tok }

<> named_member 

  >  "." prim::var^name

    :ast  { t_NamedMember, name, tok }

<> member_root 

  >  prim::var^name

    :ast { t_Variable, name, tok }

<> primitive_bool 

  > prim::true

    :ast { t_RawTrue }

  | prim::false

    :ast { t_RawFalse }

<> primitive_value

  > primitive_number

<> primitive_number 

  > prim::sci_num

<> primitive_unsigned_integer 

  > prim::uint

    :ast { t_RawUint, val:i64($1), tok }

<> primitive_integer 

  > prim::int

    :ast { t_RawInt, val:i64($1), tok }


<> aggregate_instantiation 

  > ':[' aggregate_member_initializer(*",")^inits ","(*) "]"

    :ast  { t_RawAggregateInstantiation, allocator_binding, inits, tok }

  | prim::string^data

    :ast  { t_RawCharacterInstantiation, allocator_binding, data: str($1<1,1>), tok }


<> aggregate_member_initializer 

  > (prim::var "=" :ast $1 )?^name expression

    :ast  { t_RawAggregateMemberInit, name, expression, tok  }


