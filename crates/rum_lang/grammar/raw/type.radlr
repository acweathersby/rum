IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT ../common/primitive as prim
IMPORT ./expression as expr
IMPORT annotation as anno
IMPORT ../common/comment as cmt

IGNORE { c:sp c:nl }

<> type > base_type | pointer_type | reference_type

<> pointer_type > anno::lifetime^ptr_type base_type^ty :ast { t_Type_Pointer, ptr_type, ty }

<> reference_type > "&" base_type^ty :ast { t_Type_Reference, ty }

<> base_type 

  > primitive_type

  | named_type

  | complex_type

  | generic_type

<> generic_type > "?" :ast { t_Type_Generic }

<> named_type > prim::var^name :ast { t_Type_Variable, name }

<> primitive_type
  > primitive_uint
  | primitive_int
  | "f32"   :ast { t_Type_f32 }
  | "f64"   :ast { t_Type_f64 }
  | "f128"  :ast { t_Type_f128 }
  | "f32v2" :ast { t_Type_f32v2 }
  | "f32v3" :ast { t_Type_f32v3 }
  | "f32v4" :ast { t_Type_f32v4 }
  | "f32v8" :ast { t_Type_f32v8 }
  | "f64v2" :ast { t_Type_f64v2 }
  | "f64v4" :ast { t_Type_f64v4 }

<> primitive_int 
  > "i8"    :ast { t_Type_i8 }
  | "i16"   :ast { t_Type_i16 }
  | "i32"   :ast { t_Type_i32 }
  | "i64"   :ast { t_Type_i64 }

<> primitive_uint 
  > "u8"    :ast { t_Type_u8 }
  | "u16"   :ast { t_Type_u16 }
  | "u32"   :ast { t_Type_u32 }
  | "u64"   :ast { t_Type_u64 }

<> complex_type > structure_type | array_type | union_type | enum_type | flag_type

<> structure_type

  > "[" property(+",")^properties ","(*) "]"

    :ast { t_Type_Struct, properties, tok }

<> property 

  > prim::var^name ":" type^ty

      :ast  { t_Property, name, ty, tok  }

<> array_type

  > "[" type^base_type (";" prim::int )?^size "]"

    :ast { t_Type_Array, base_type, size: u32($size), tok }

<> union_type 

  > prim::var "|" prim::var(+"|")^ids

    :ast  { t_Type_Union, ids: $1 + $3, tok }

<> enum_type 

  > primitive_type^base_type ">" ":" enum_value(+":")^values

    :ast  { t_Type_Enum, base_type, values, tok }

<> enum_value 

  > prim::var^name ( "=>" expr::expression )?^expression

    :ast  { t_EnumValue, name, expression  }

<> flag_type 

  > flag_val^flag_val ">" ":" prim::var(+":")^values

    :ast  { t_Type_Flag, flag_size: u32($flag_val<4, 0>), values, tok }

<> flag_val > tk:( "flag" c:num+ )

<> bitfield_type 

  > tk:( 'b' "f" c:num+ )^base_type  ">" "+" bitfield_element(+"+")^props

    :ast  { t_RawBitCompositeProp, bit_count: u32($base_type<2,0>), props  }

<> bitfield_element

  > prim::var^name ":" (primitive_type | discriminator_type)^type

      :ast  { t_BitFieldProp, name, type, tok  }

<> discriminator_type > 

  tk:( "#desc" c:num+ )

      :ast  { t_Discriminator, bit_count: u32($1<5,0>)  }