IGNORE { c:sp c:nl tk:cmt::comment ";" }
IMPORT ./expression as expr
IMPORT ./complex as complex
IMPORT ./annotation as anno

IMPORT type as ty
IMPORT ../common/primitive as prim
IMPORT ../common/comment as cmt

<> statement 
  > loop_statement 
  | assignment_statement 
  | expression_statement
  | iterator_definition

<> expression_statement > expr::expression

<> block_expression 

  > "{" ( anno::annotation | allocator_binding )(*)^attributes statement(*)^statements ( return_statement | break_statement | yield_statement )?^exit "}"

    :ast { t_RawBlock, statements, attributes, exit }

+> expr::term > block_expression

<> iterator_definition 

  >  "iter" ( block_expression | match_expression )^expr

    :ast { t_IterReentrance, expr, tok }

<> allocator_binding 

  > anno::lifetime^binding_name "=>" prim::var^allocator_name "(" anno::lifetime?^parent_allocator ")"

    :ast { t_RawAllocatorBinding, binding_name, allocator_name, parent_allocator, tok }

<> assignment_statement 

  > assignment_var^var "=" expr::expression{2}^expression

    :ast { t_RawAssignment, var, expression, tok  }

  | expr::member^to "<:" expr::member^from

    :ast { t_RawMove, to, from, tok  }

<> assignment_var 

  > prim::var^var ":" ty::type

    :ast { t_RawAssignmentDeclaration, var:$1, ty:$3, tok  }

  | expr::member

<> break_statement 

  > "break" ("#" prim::var)?^label

    :ast { t_RawBreak, label, tok  }

<> yield_statement 

  > "yield" expr::expression^expr

    :ast { t_RawYield, expr, tok  }

<> return_statement

  > "ret" expr::expression^expression

    :ast { t_BlockExitExpressions, expression }

<> loop_statement 

  > "loop" ("#" prim::var)?^label ( match_expression | block_expression | iter_statement)^scope

    :ast { t_RawLoop, label, scope, tok  }


+> expr::term > match_expression

<> match_expression 

  > "if" expr::l_val^expression ( ( "as" | "=>"  ) prim::var )?^binding_name match_clause(+)^clauses default_clause?

    :ast { t_RawMatch, expression, clauses, default_clause, binding_name, tok  }


<> default_clause 

  >  ( "or" | "else" | "otherwise" ) block_expression

    :ast { t_RawMatchClause, default: true, scope: $2, tok }

<> match_clause 

  > match_condition block_expression

    :ast { t_RawMatchClause, default: false, expr:$1, scope: $2, tok }

<> match_condition
 
  > "is" prim::var^var

    :ast { t_RawTypeMatchExpr, name: $var, tok  }

  | ( ">" | "<" | ">=" | "<=" | "==" | "!=" ) expr::r_val^expr

    :ast { t_RawExprMatch, op:str($1), expr: $2, tok  }

<> iter_statement 

  > prim::var^var "in" expr::call^iter block_expression^block

    :ast { t_RawIterStatement, var, iter, block, tok }