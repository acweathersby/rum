IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT ./expression as expr
IMPORT ./complex as complex
IMPORT ./annotation as anno

IMPORT type as ty
IMPORT ../common/primitive as prim
IMPORT ../common/comment as cmt

<> statement 
  > loop_statement 
  | match_statement 
  | assignment_statement 
  | expression_statement

<> expression_statement > expr::expression

<> block_expression 

  > "{" ( anno::annotation | allocator_binding )(*)^attributes statement(+)^statements ( block_exit_expressions | break_statement )?^exit "}"

    :ast { t_RawBlock, statements, attributes, exit }


<> allocator_binding 
  
  > anno::lifetime^binding_name "=" prim::var^allocator_name "(" anno::lifetime?^parent_allocator ")"

    :ast { t_RawAllocatorBinding, binding_name, allocator_name, parent_allocator }


+> expr::term > block_expression


<> assignment_statement 

  > assignment_var(+",")^vars "=" expr::expression(+","){2}^expressions

    :ast { t_RawAssignment, vars, expressions, tok  }


<> assignment_var 

  > prim::var^var ":" ty::type

    :ast { t_RawAssignmentDeclaration, var:$1, ty:$3, tok  }

  | expr::member

    :ast { t_RawAssignmentVariable, var:$1, tok  }

  | complex::region_access


<> break_statement 

  > "break" ("#" prim::var)?^label ";"?

    :ast { t_RawBreak, label, tok  }


<> loop_statement 

  > "loop" ("#" prim::var)?^label ( match_statement | block_expression ){1}^scope
    
    :ast { t_RawLoop, label, scope, tok  }


<> match_statement 

  > "if" expr::expression^expression "is" match_clause(+){2}^clauses

    :ast { t_RawMatch, expression, clauses, tok  }


<> match_clause 

  > match_expression match_scope
    
    :ast { t_RawMatchClause, expr:$1, scope: $2 }

  | ( "?" | "or" | "else" | "otherwise" ) match_scope

    :ast { t_RawDefaultClause, scope: $2 }

<> match_scope 
  
  > block_expression 
  
  | ":" expr::expression

<> match_expression

  > ( ">" | "<" | ">=" | "<=" | "==" | "!=" ) expr::expression

    :ast { t_RawExprMatch, op:str($1), expr: $2, tok  }

  | ( expr::primitive_value | expr::primitive_bool | prim::var )

    :ast { t_RawValMatch, val: $1, tok  }

<> block_exit_expressions

  > "<-" expr::expression^expression

    :ast { t_BlockExitExpressions, expression }


<>  range > "[" "..." "]"
