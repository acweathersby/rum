IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT type as ty
IMPORT ./expression as expr
IMPORT annotation as anno
IMPORT ../common/primitive as prim
IMPORT ../common/comment as cmt


<> array 
  
  > prim::var^name "=>" anno::lifetime?^allocator_binding "[" ty::type^ty (";" prim::int )?^size "]"

      :ast  { t_RawArray, allocator_binding, name, ty, size, tok }


<> enum 
  
  > prim::var^name "=>" prim::var(+"|")^ids

    :ast  { t_RawUnion, name, ids, tok }

  | prim::var^name "=>" ty::primitive_type ":" enum_value(+",")^values

    :ast  { t_RawEnum, name, values, tok }

  | prim::var^name "=>" flag_val ":" prim::var(+",")^ids

    :ast  { t_RawBitFlagEnum, name, ids, tok }


<> enum_value 

  > prim::var^name ( "=" expr::expression )?^expression

    :ast  { t_EnumValue, name, expression  }


<> flag_val > tk:( "flag" c:num+ )


<> structure 
  
  > prim::var^name "=>" anno::lifetime?^allocator_binding "[" property(+",")^properties ","(*) "]"

    :ast  { t_RawStruct, allocator_binding, name, properties, tok }


<> property 

  > single_prop

  | bitfield_prop


<> bitfield_prop 

  > tk:( 'b' "f" c:num+ )^base_type ":" bitfield_element(+"|")^props

    :ast  { t_RawBitCompositeProp, bit_count: u32($base_type<2,0>), props  }

  


<> bitfield_element

  > prim::var^name ":" ty::type^type "?"?^optional

      :ast  { t_BitFieldProp, name, type, tok, optional: bool($optional)  }
      
  | tk:( "#desc" c:num+ )

      :ast  { t_BitFieldDescriminator, bit_count: u32($1<5,0>)  }


<> single_prop 

  > prim::var^name ":" ty::type^type "?"?^optional

      :ast  { t_RawProperty, name, type, tok, optional: bool($optional)  }


+> expr::expression_types > structural_instantiation


+> expr::term > region_access


<> structural_instantiation 

  > ( "heap" anno::lifetime | "heap" :ast { t_GlobalHeapBinding })?^allocator_binding prim::var^name "[" structure_member_initializer(*",")^inits ","(*) "]"

    :ast  { t_RawStructInstantiation, allocator_binding, name, inits, tok }


<> region_access

  > prim::var^name "[" expr::pointer_offset^expression "]"

    :ast  { t_RawArrayAccess, name, expression, tok }


<> structure_member_initializer 

  > prim::var^name "=" expr::expression

    :ast  { t_RawStructMemberInit, name, expression  }

