IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT type as ty
IMPORT ../common/primitive as prim
IMPORT ../common/comment as cmt


<> expression > expression_types
    
    :ast { t_Expression, expr: $1, tok }

<> expression_types

  > bitwise


<> pointer_offset 

  > pointer_offset^left "+"{1} pointer_offset{0}^right

    :ast { t_RawMemAdd, left, right, tok }

  | pointer_offset^left "*"{3} pointer_offset{2}^right

    :ast { t_RawMemMul, left, right, tok }

  | member

  | primitive_integer


<> boolean 

  > boolean^left "||"{1}  boolean{0}^right
    
    :ast { t_OR, left, right, tok } 

  | boolean^left "|||"{3}  boolean{2}^right
    
    :ast { t_XOR, left, right, tok } 

  | boolean^left "&&"{5}  boolean{4}^right
    
    :ast { t_AND, left, right, tok }

  | logical

  | "(" boolean ")"
    
    :ast $2


<> logical 

  > bitwise^left "=="{3}  bitwise{3}^right
    
    :ast { t_EQ, left, right, tok } 

  | bitwise^left "!="{3}  bitwise{3}^right
    
    :ast { t_NE, left, right, tok } 

  | bitwise^left ">="{3}  bitwise{3}^right
    
    :ast { t_GE, left, right, tok } 

  | bitwise^left "<="{3}  bitwise{3}^right
    
    :ast { t_LE, left, right, tok } 

  | bitwise^left  ">"{3}  bitwise{3}^right
    
    :ast { t_GR, left, right, tok } 

  | bitwise^left  "<"{3}  bitwise{3}^right
    
    :ast { t_LS, left, right, tok } 

  | "!"{4} logical^expr{3}
    
    :ast { t_NOT, expr }


<> bitwise 

  > bitwise^left  ">>"{5}  bitwise{4}^right
    
    :ast { t_BIT_SR, left, right, tok } 

  | bitwise^left  "<<"{5}  bitwise{4}^right
    
    :ast { t_BIT_SL, left, right, tok } 

  | bitwise^left "&"{3}  bitwise{2}^right
    
    :ast { t_BIT_AND, left, right, tok } 

  | bitwise^left "|"{3}  bitwise{2}^right
    
    :ast { t_BIT_OR, left, right, tok } 

  | bitwise^left "~|"{3}  bitwise{2}^right
    
    :ast { t_BIT_XOR, left, right, tok } 

  | arithmetic


<> arithmetic 
  
  > arithmetic^left   "+"{2}  arithmetic{1}^right
    
    :ast { t_Add, right, left, tok }

  | arithmetic^left   "-"{2}  arithmetic{1}^right
    
    :ast { t_Sub, right, left, tok }

  | arithmetic^left   "*"{4}  arithmetic{3}^right
    
    :ast { t_Mul, right, left, tok }

  | arithmetic^left   "/"{4}  arithmetic{3}^right
    
    :ast { t_Div, right, left, tok }

  | arithmetic^left   "%"{4}  arithmetic{3}^right
    
    :ast { t_Mod, right, left, tok }

  | arithmetic^left  "**"{6}  arithmetic{5}^right
    
    :ast { t_Pow, right, left, tok }

  | arithmetic^left  "//"{6}  arithmetic{5}^right
    
    :ast { t_Root, right, left, tok }

  | arithmetic^left "log"{6}  arithmetic{5}^right
    
    :ast { t_Log, right, left, tok }

  | "-"{7} arithmetic^expr{6}
    
    :ast { t_Negate, expr, tok }

  | term


<> term 

  > r_val

  | call

  | "(" expression_types ")"

    :ast $1

<> r_val 

  > primitive_value

  | member

    
<> l_val 

  > member


<> call 

  > member^member "("{1} expression(*",")^args ")"

    :ast { t_RawCall, member, args, tok }


<> member 
  
  > member_root{1}^root ( indexed_member | named_member )(*)^sub_members{2}

    :ast { t_MemberCompositeAccess, root, sub_members, tok }


<> indexed_member 

  >  "[" pointer_offset^expression "]"

    :ast  { t_IndexedMember, expression, tok }


<> named_member 

  >  "." prim::var^name

    :ast  { t_NamedMember, name, tok }


<> member_root 
  
  >  prim::var^name

    :ast { t_Variable, name, tok }


<> primitive_bool 

  > prim::true

    :ast { t_RawTrue }

  | prim::false

    :ast { t_RawFalse }


<> primitive_value

  > primitive_number

  | primitive_string  


<> primitive_string  
  
  >  prim::string

    :ast { t_RawStr, val:str($1), tok  }


<> primitive_number 

  > prim::sci_num

    :ast { t_RawNum, val:f64($1), tok }


<> primitive_unsigned_integer 

  > prim::uint

    :ast { t_RawUint, val:i64($1), tok }


<> primitive_integer 

  > prim::int

    :ast { t_RawInt, val:i64($1), tok }




