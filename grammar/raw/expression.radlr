IGNORE { c:sp c:nl tk:cmt::comment }

IMPORT type as ty
IMPORT ../common/primitive as prim
IMPORT ../common/comment as cmt


<> expression > expression_types
    
    :ast { t_Expression, expr: $1, tok }

<> expression_types

  > bitwise


<> pointer_offset 

  > pointer_offset^left "+"{1} pointer_offset{0}^right

    :ast { t_RawMemAdd, left, right, tok }

  | pointer_offset^left "*"{3} pointer_offset{2}^right

    :ast { t_RawMemMul, left, right, tok }

  | member

  | primitive_integer


<> boolean 

  > boolean^left "||"{1}  boolean{0}^right
    
    :ast { t_OR, left, right, tok } 

  | boolean^left "|||"{3}  boolean{2}^right
    
    :ast { t_XOR, left, right, tok } 

  | boolean^left "&&"{5}  boolean{4}^right
    
    :ast { t_AND, left, right, tok }

  | logical

  | "(" boolean ")"
    
    :ast $2


<> logical 

  > bitwise^left "=="{3}  bitwise{3}^right
    
    :ast { t_EQ, left, right, tok } 

  | bitwise^left "!="{3}  bitwise{3}^right
    
    :ast { t_NE, left, right, tok } 

  | bitwise^left ">="{3}  bitwise{3}^right
    
    :ast { t_GE, left, right, tok } 

  | bitwise^left "<="{3}  bitwise{3}^right
    
    :ast { t_LE, left, right, tok } 

  | bitwise^left  ">"{3}  bitwise{3}^right
    
    :ast { t_GR, left, right, tok } 

  | bitwise^left  "<"{3}  bitwise{3}^right
    
    :ast { t_LS, left, right, tok } 

  | "!"{4} logical^expr{3}
    
    :ast { t_NOT, expr }


<> bitwise 

  > bitwise^left  ">>"{5}  bitwise{4}^right
    
    :ast { t_BIT_SR, left, right, tok } 

  | bitwise^left  "<<"{5}  bitwise{4}^right
    
    :ast { t_BIT_SL, left, right, tok } 

  | bitwise^left "&"{3}  bitwise{2}^right
    
    :ast { t_BIT_AND, left, right, tok } 

  | bitwise^left "|"{3}  bitwise{2}^right
    
    :ast { t_BIT_OR, left, right, tok } 

  | bitwise^left "~|"{3}  bitwise{2}^right
    
    :ast { t_BIT_XOR, left, right, tok } 

  | arithmetic


<> arithmetic 
  
  > arithmetic^left   "+"{2}  arithmetic{1}^right
    
    :ast { t_Add, right, left, tok }

  | arithmetic^left   "-"{2}  arithmetic{1}^right
    
    :ast { t_Sub, right, left, tok }

  | arithmetic^left   "*"{4}  arithmetic{3}^right
    
    :ast { t_Mul, right, left, tok }

  | arithmetic^left   "/"{4}  arithmetic{3}^right
    
    :ast { t_Div, right, left, tok }

  | arithmetic^left   "%"{4}  arithmetic{3}^right
    
    :ast { t_Mod, right, left, tok }

  | arithmetic^left  "**"{6}  arithmetic{5}^right
    
    :ast { t_Pow, right, left, tok }

  | arithmetic^left  "//"{6}  arithmetic{5}^right
    
    :ast { t_Root, right, left, tok }

  | arithmetic^left "log"{6}  arithmetic{5}^right
    
    :ast { t_Log, right, left, tok }

  | "-"{7} arithmetic^expr{6}
    
    :ast { t_Negate, expr, tok }

  | term


<> term 

  > call

  | primitive_value

  | region_access

  | "(" expression_types(+",")^expressions ")"
    
    :ast { t_RawTuple, expressions }


<> call 

  > region_access^member "("{1} expression(*",")^args ")"

    :ast { t_RawCall, member, args, tok }


<> region_access

  > member

  | member^name{1} "["{2} pointer_offset^expression "]"

    :ast  { t_RawArrayAccess, name, expression, tok }

<> member 
  
  > prim::var(+".")^members

    :ast { t_RawMember, members, tok }


<> primitive_bool 

  > prim::true

    :ast { t_RawTrue }

  | prim::false

    :ast { t_RawFalse }

<> primitive_value

  > primitive_number

  | prim::string^val

    :ast { t_RawStr, val:str($val), tok  }


<> primitive_number 

  > prim::sci_num

    :ast { t_RawNum, val:f64($1), tok }


<> primitive_unsigned_integer 

  > prim::uint

    :ast { t_RawUint, val:i64($1), tok }


<> primitive_integer 

  > prim::int

    :ast { t_RawInt, val:i64($1), tok }




